<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>wiki.core API documentation</title>
<meta name="description" content="Wiki core
~~~~~~~~~" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wiki.core</code></h1>
</header>
<section id="section-intro">
<p>Wiki core
~~~~~~~~~</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Wiki core
    ~~~~~~~~~
&#34;&#34;&#34;
from collections import OrderedDict
from io import open
import os
import re

from flask import abort
from flask import url_for
import markdown


def clean_url(url):
    &#34;&#34;&#34;
        Cleans the url and corrects various errors. Removes multiple
        spaces and all leading and trailing spaces. Changes spaces
        to underscores and makes all characters lowercase. Also
        takes care of Windows style folders use.

        :param str url: the url to clean


        :returns: the cleaned url
        :rtype: str
    &#34;&#34;&#34;
    url = re.sub(&#39;[ ]{2,}&#39;, &#39; &#39;, url).strip()
    url = url.lower().replace(&#39; &#39;, &#39;_&#39;)
    url = url.replace(&#39;\\\\&#39;, &#39;/&#39;).replace(&#39;\\&#39;, &#39;/&#39;)
    return url


def wikilink(text, url_formatter=None):
    &#34;&#34;&#34;
        Processes Wikilink syntax &#34;[[Link]]&#34; within the html body.
        This is intended to be run after content has been processed
        by markdown and is already HTML.

        :param str text: the html to highlight wiki links in.
        :param function url_formatter: which URL formatter to use,
            will by default use the flask url formatter

        Syntax:
            This accepts Wikilink syntax in the form of [[WikiLink]] or
            [[url/location|LinkName]]. Everything is referenced from the
            base location &#34;/&#34;, therefore sub-pages need to use the
            [[page/subpage|Subpage]].

        :returns: the processed html
        :rtype: str
    &#34;&#34;&#34;
    if url_formatter is None:
        url_formatter = url_for
    link_regex = re.compile(
        r&#34;((?&lt;!\&lt;code\&gt;)\[\[([^&lt;].+?) \s*([|] \s* (.+?) \s*)?]])&#34;,
        re.X | re.U
    )
    for i in link_regex.findall(text):
        title = [i[-1] if i[-1] else i[1]][0]
        url = clean_url(i[1])
        html_url = &#34;&lt;a href=&#39;{0}&#39;&gt;{1}&lt;/a&gt;&#34;.format(
            url_formatter(&#39;wiki.display&#39;, url=url),
            title
        )
        text = re.sub(link_regex, html_url, text, count=1)
    return text


class Processor(object):
    &#34;&#34;&#34;
        The processor handles the processing of file content into
        metadata and markdown and takes care of the rendering.

        It also offers some helper methods that can be used for various
        cases.
    &#34;&#34;&#34;

    preprocessors = []
    postprocessors = [wikilink]

    def __init__(self, text):
        &#34;&#34;&#34;
            Initialization of the processor.

            :param str text: the text to process
        &#34;&#34;&#34;
        self.md = markdown.Markdown([
            &#39;codehilite&#39;,
            &#39;fenced_code&#39;,
            &#39;meta&#39;,
            &#39;tables&#39;
        ])
        self.input = text
        self.markdown = None
        self.meta_raw = None

        self.pre = None
        self.html = None
        self.final = None
        self.meta = None

    def process_pre(self):
        &#34;&#34;&#34;
            Content preprocessor.
        &#34;&#34;&#34;
        current = self.input
        for processor in self.preprocessors:
            current = processor(current)
        self.pre = current

    def process_markdown(self):
        &#34;&#34;&#34;
            Convert to HTML.
        &#34;&#34;&#34;
        self.html = self.md.convert(self.pre)


    def split_raw(self):
        &#34;&#34;&#34;
            Split text into raw meta and content.
        &#34;&#34;&#34;
        self.meta_raw, self.markdown = self.pre.split(&#39;\n\n&#39;, 1)

    def process_meta(self):
        &#34;&#34;&#34;
            Get metadata.

            .. warning:: Can only be called after :meth:`html` was
                called.
        &#34;&#34;&#34;
        # the markdown meta plugin does not retain the order of the
        # entries, so we have to loop over the meta values a second
        # time to put them into a dictionary in the correct order
        self.meta = OrderedDict()
        for line in self.meta_raw.split(&#39;\n&#39;):
            key = line.split(&#39;:&#39;, 1)[0]
            # markdown metadata always returns a list of lines, we will
            # reverse that here
            self.meta[key.lower()] = \
                &#39;\n&#39;.join(self.md.Meta[key.lower()])

    def process_post(self):
        &#34;&#34;&#34;
            Content postprocessor.
        &#34;&#34;&#34;
        current = self.html
        for processor in self.postprocessors:
            current = processor(current)
        self.final = current

    def process(self):
        &#34;&#34;&#34;
            Runs the full suite of processing on the given text, all
            pre and post processing, markdown rendering and meta data
            handling.
        &#34;&#34;&#34;
        self.process_pre()
        self.process_markdown()
        self.split_raw()
        self.process_meta()
        self.process_post()

        return self.final, self.markdown, self.meta


class Page(object):
    def __init__(self, path, url, new=False):
        self.path = path
        self.url = url
        self._meta = OrderedDict()
        if not new:
            self.load()
            self.render()

    def __repr__(self):
        return &#34;&lt;Page: {}@{}&gt;&#34;.format(self.url, self.path)

    def load(self):
        with open(self.path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            self.content = f.read()

    def render(self):
        processor = Processor(self.content)
        self._html, self.body, self._meta = processor.process()

    def save(self, update=True):
        folder = os.path.dirname(self.path)
        if not os.path.exists(folder):
            os.makedirs(folder)
        with open(self.path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            for key, value in list(self._meta.items()):
                line = &#39;%s: %s\n&#39; % (key, value)
                f.write(line)
            f.write(&#39;\n&#39;)
            f.write(self.body.replace(&#39;\r\n&#39;, &#39;\n&#39;))
        if update:
            self.load()
            self.render()

    @property
    def meta(self):
        return self._meta

    def __getitem__(self, name):
        return self._meta[name]

    def __setitem__(self, name, value):
        self._meta[name] = value

    @property
    def html(self):
        return self._html

    def __html__(self):
        return self.html

    @property
    def title(self):
        try:
            return self[&#39;title&#39;]
        except KeyError:
            return self.url

    @title.setter
    def title(self, value):
        self[&#39;title&#39;] = value

    @property
    def tags(self):
        try:
            return self[&#39;tags&#39;]
        except KeyError:
            return &#34;&#34;

    @tags.setter
    def tags(self, value):
        self[&#39;tags&#39;] = value


class Wiki(object):
    def __init__(self, root):
        self.root = root

    def path(self, url):
        return os.path.join(self.root, url + &#39;.md&#39;)

    def exists(self, url):
        path = self.path(url)
        return os.path.exists(path)

    def get(self, url):
        path = self.path(url)
        #path = os.path.join(self.root, url + &#39;.md&#39;)
        if self.exists(url):
            return Page(path, url)
        return None

    def get_or_404(self, url):
        page = self.get(url)
        if page:
            return page
        abort(404)

    def get_bare(self, url):
        path = self.path(url)
        if self.exists(url):
            return False
        return Page(path, url, new=True)

    def move(self, url, newurl):
        source = os.path.join(self.root, url) + &#39;.md&#39;
        target = os.path.join(self.root, newurl) + &#39;.md&#39;
        # normalize root path (just in case somebody defined it absolute,
        # having some &#39;../&#39; inside) to correctly compare it to the target
        root = os.path.normpath(self.root)
        # get root path longest common prefix with normalized target path
        common = os.path.commonprefix((root, os.path.normpath(target)))
        # common prefix length must be at least as root length is
        # otherwise there are probably some &#39;..&#39; links in target path leading
        # us outside defined root directory
        if len(common) &lt; len(root):
            raise RuntimeError(
                &#39;Possible write attempt outside content directory: &#39;
                &#39;%s&#39; % newurl)
        # create folder if it does not exists yet
        folder = os.path.dirname(target)
        if not os.path.exists(folder):
            os.makedirs(folder)
        os.rename(source, target)

    def delete(self, url):
        path = self.path(url)
        if not self.exists(url):
            return False
        os.remove(path)
        return True

    def index(self):
        &#34;&#34;&#34;
            Builds up a list of all the available pages.

            :returns: a list of all the wiki pages
            :rtype: list
        &#34;&#34;&#34;
        # make sure we always have the absolute path for fixing the
        # walk path
        pages = []
        root = os.path.abspath(self.root)
        for cur_dir, _, files in os.walk(root):
            # get the url of the current directory
            cur_dir_url = cur_dir[len(root)+1:]
            for cur_file in files:
                path = os.path.join(cur_dir, cur_file)
                if cur_file.endswith(&#39;.md&#39;):
                    url = clean_url(os.path.join(cur_dir_url, cur_file[:-3]))
                    page = Page(path, url)
                    pages.append(page)
        return sorted(pages, key=lambda x: x.title.lower())

    def index_by(self, key):
        &#34;&#34;&#34;
            Get an index based on the given key.

            Will use the metadata value of the given key to group
            the existing pages.

            :param str key: the attribute to group the index on.

            :returns: Will return a dictionary where each entry holds
                a list of pages that share the given attribute.
            :rtype: dict
        &#34;&#34;&#34;
        pages = {}
        for page in self.index():
            value = getattr(page, key)
            pre = pages.get(value, [])
            pages[value] = pre.append(page)
        return pages

    def get_by_title(self, title):
        pages = self.index(attr=&#39;title&#39;)
        return pages.get(title)

    def get_tags(self):
        pages = self.index()
        tags = {}
        for page in pages:
            pagetags = page.tags.split(&#39;,&#39;)
            for tag in pagetags:
                tag = tag.strip()
                if tag == &#39;&#39;:
                    continue
                elif tags.get(tag):
                    tags[tag].append(page)
                else:
                    tags[tag] = [page]
        return tags

    def index_by_tag(self, tag):
        pages = self.index()
        tagged = []
        for page in pages:
            if tag in page.tags:
                tagged.append(page)
        return sorted(tagged, key=lambda x: x.title.lower())

    def search(self, term, ignore_case=True, attrs=[&#39;title&#39;, &#39;tags&#39;, &#39;body&#39;]):
        pages = self.index()
        regex = re.compile(term, re.IGNORECASE if ignore_case else 0)
        matched = []
        for page in pages:
            for attr in attrs:
                if regex.search(getattr(page, attr)):
                    matched.append(page)
                    break
        return matched</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wiki.core.clean_url"><code class="name flex">
<span>def <span class="ident">clean_url</span></span>(<span>url)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans the url and corrects various errors. Removes multiple
spaces and all leading and trailing spaces. Changes spaces
to underscores and makes all characters lowercase. Also
takes care of Windows style folders use.</p>
<p>:param str url: the url to clean</p>
<p>:returns: the cleaned url
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_url(url):
    &#34;&#34;&#34;
        Cleans the url and corrects various errors. Removes multiple
        spaces and all leading and trailing spaces. Changes spaces
        to underscores and makes all characters lowercase. Also
        takes care of Windows style folders use.

        :param str url: the url to clean


        :returns: the cleaned url
        :rtype: str
    &#34;&#34;&#34;
    url = re.sub(&#39;[ ]{2,}&#39;, &#39; &#39;, url).strip()
    url = url.lower().replace(&#39; &#39;, &#39;_&#39;)
    url = url.replace(&#39;\\\\&#39;, &#39;/&#39;).replace(&#39;\\&#39;, &#39;/&#39;)
    return url</code></pre>
</details>
</dd>
<dt id="wiki.core.wikilink"><code class="name flex">
<span>def <span class="ident">wikilink</span></span>(<span>text, url_formatter=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes Wikilink syntax "[[Link]]" within the html body.
This is intended to be run after content has been processed
by markdown and is already HTML.</p>
<p>:param str text: the html to highlight wiki links in.
:param function url_formatter: which URL formatter to use,
will by default use the flask url formatter</p>
<h2 id="syntax">Syntax</h2>
<p>This accepts Wikilink syntax in the form of [[WikiLink]] or
[[url/location|LinkName]]. Everything is referenced from the
base location "/", therefore sub-pages need to use the
[[page/subpage|Subpage]].</p>
<p>:returns: the processed html
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wikilink(text, url_formatter=None):
    &#34;&#34;&#34;
        Processes Wikilink syntax &#34;[[Link]]&#34; within the html body.
        This is intended to be run after content has been processed
        by markdown and is already HTML.

        :param str text: the html to highlight wiki links in.
        :param function url_formatter: which URL formatter to use,
            will by default use the flask url formatter

        Syntax:
            This accepts Wikilink syntax in the form of [[WikiLink]] or
            [[url/location|LinkName]]. Everything is referenced from the
            base location &#34;/&#34;, therefore sub-pages need to use the
            [[page/subpage|Subpage]].

        :returns: the processed html
        :rtype: str
    &#34;&#34;&#34;
    if url_formatter is None:
        url_formatter = url_for
    link_regex = re.compile(
        r&#34;((?&lt;!\&lt;code\&gt;)\[\[([^&lt;].+?) \s*([|] \s* (.+?) \s*)?]])&#34;,
        re.X | re.U
    )
    for i in link_regex.findall(text):
        title = [i[-1] if i[-1] else i[1]][0]
        url = clean_url(i[1])
        html_url = &#34;&lt;a href=&#39;{0}&#39;&gt;{1}&lt;/a&gt;&#34;.format(
            url_formatter(&#39;wiki.display&#39;, url=url),
            title
        )
        text = re.sub(link_regex, html_url, text, count=1)
    return text</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wiki.core.Page"><code class="flex name class">
<span>class <span class="ident">Page</span></span>
<span>(</span><span>path, url, new=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Page(object):
    def __init__(self, path, url, new=False):
        self.path = path
        self.url = url
        self._meta = OrderedDict()
        if not new:
            self.load()
            self.render()

    def __repr__(self):
        return &#34;&lt;Page: {}@{}&gt;&#34;.format(self.url, self.path)

    def load(self):
        with open(self.path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            self.content = f.read()

    def render(self):
        processor = Processor(self.content)
        self._html, self.body, self._meta = processor.process()

    def save(self, update=True):
        folder = os.path.dirname(self.path)
        if not os.path.exists(folder):
            os.makedirs(folder)
        with open(self.path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            for key, value in list(self._meta.items()):
                line = &#39;%s: %s\n&#39; % (key, value)
                f.write(line)
            f.write(&#39;\n&#39;)
            f.write(self.body.replace(&#39;\r\n&#39;, &#39;\n&#39;))
        if update:
            self.load()
            self.render()

    @property
    def meta(self):
        return self._meta

    def __getitem__(self, name):
        return self._meta[name]

    def __setitem__(self, name, value):
        self._meta[name] = value

    @property
    def html(self):
        return self._html

    def __html__(self):
        return self.html

    @property
    def title(self):
        try:
            return self[&#39;title&#39;]
        except KeyError:
            return self.url

    @title.setter
    def title(self, value):
        self[&#39;title&#39;] = value

    @property
    def tags(self):
        try:
            return self[&#39;tags&#39;]
        except KeyError:
            return &#34;&#34;

    @tags.setter
    def tags(self, value):
        self[&#39;tags&#39;] = value</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wiki.core.Page.html"><code class="name">var <span class="ident">html</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def html(self):
    return self._html</code></pre>
</details>
</dd>
<dt id="wiki.core.Page.meta"><code class="name">var <span class="ident">meta</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def meta(self):
    return self._meta</code></pre>
</details>
</dd>
<dt id="wiki.core.Page.tags"><code class="name">var <span class="ident">tags</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tags(self):
    try:
        return self[&#39;tags&#39;]
    except KeyError:
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="wiki.core.Page.title"><code class="name">var <span class="ident">title</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def title(self):
    try:
        return self[&#39;title&#39;]
    except KeyError:
        return self.url</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wiki.core.Page.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self):
    with open(self.path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
        self.content = f.read()</code></pre>
</details>
</dd>
<dt id="wiki.core.Page.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self):
    processor = Processor(self.content)
    self._html, self.body, self._meta = processor.process()</code></pre>
</details>
</dd>
<dt id="wiki.core.Page.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, update=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, update=True):
    folder = os.path.dirname(self.path)
    if not os.path.exists(folder):
        os.makedirs(folder)
    with open(self.path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
        for key, value in list(self._meta.items()):
            line = &#39;%s: %s\n&#39; % (key, value)
            f.write(line)
        f.write(&#39;\n&#39;)
        f.write(self.body.replace(&#39;\r\n&#39;, &#39;\n&#39;))
    if update:
        self.load()
        self.render()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wiki.core.Processor"><code class="flex name class">
<span>class <span class="ident">Processor</span></span>
<span>(</span><span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>The processor handles the processing of file content into
metadata and markdown and takes care of the rendering.</p>
<p>It also offers some helper methods that can be used for various
cases.</p>
<p>Initialization of the processor.</p>
<p>:param str text: the text to process</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Processor(object):
    &#34;&#34;&#34;
        The processor handles the processing of file content into
        metadata and markdown and takes care of the rendering.

        It also offers some helper methods that can be used for various
        cases.
    &#34;&#34;&#34;

    preprocessors = []
    postprocessors = [wikilink]

    def __init__(self, text):
        &#34;&#34;&#34;
            Initialization of the processor.

            :param str text: the text to process
        &#34;&#34;&#34;
        self.md = markdown.Markdown([
            &#39;codehilite&#39;,
            &#39;fenced_code&#39;,
            &#39;meta&#39;,
            &#39;tables&#39;
        ])
        self.input = text
        self.markdown = None
        self.meta_raw = None

        self.pre = None
        self.html = None
        self.final = None
        self.meta = None

    def process_pre(self):
        &#34;&#34;&#34;
            Content preprocessor.
        &#34;&#34;&#34;
        current = self.input
        for processor in self.preprocessors:
            current = processor(current)
        self.pre = current

    def process_markdown(self):
        &#34;&#34;&#34;
            Convert to HTML.
        &#34;&#34;&#34;
        self.html = self.md.convert(self.pre)


    def split_raw(self):
        &#34;&#34;&#34;
            Split text into raw meta and content.
        &#34;&#34;&#34;
        self.meta_raw, self.markdown = self.pre.split(&#39;\n\n&#39;, 1)

    def process_meta(self):
        &#34;&#34;&#34;
            Get metadata.

            .. warning:: Can only be called after :meth:`html` was
                called.
        &#34;&#34;&#34;
        # the markdown meta plugin does not retain the order of the
        # entries, so we have to loop over the meta values a second
        # time to put them into a dictionary in the correct order
        self.meta = OrderedDict()
        for line in self.meta_raw.split(&#39;\n&#39;):
            key = line.split(&#39;:&#39;, 1)[0]
            # markdown metadata always returns a list of lines, we will
            # reverse that here
            self.meta[key.lower()] = \
                &#39;\n&#39;.join(self.md.Meta[key.lower()])

    def process_post(self):
        &#34;&#34;&#34;
            Content postprocessor.
        &#34;&#34;&#34;
        current = self.html
        for processor in self.postprocessors:
            current = processor(current)
        self.final = current

    def process(self):
        &#34;&#34;&#34;
            Runs the full suite of processing on the given text, all
            pre and post processing, markdown rendering and meta data
            handling.
        &#34;&#34;&#34;
        self.process_pre()
        self.process_markdown()
        self.split_raw()
        self.process_meta()
        self.process_post()

        return self.final, self.markdown, self.meta</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="wiki.core.Processor.postprocessors"><code class="name">var <span class="ident">postprocessors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wiki.core.Processor.preprocessors"><code class="name">var <span class="ident">preprocessors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wiki.core.Processor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the full suite of processing on the given text, all
pre and post processing, markdown rendering and meta data
handling.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    &#34;&#34;&#34;
        Runs the full suite of processing on the given text, all
        pre and post processing, markdown rendering and meta data
        handling.
    &#34;&#34;&#34;
    self.process_pre()
    self.process_markdown()
    self.split_raw()
    self.process_meta()
    self.process_post()

    return self.final, self.markdown, self.meta</code></pre>
</details>
</dd>
<dt id="wiki.core.Processor.process_markdown"><code class="name flex">
<span>def <span class="ident">process_markdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to HTML.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_markdown(self):
    &#34;&#34;&#34;
        Convert to HTML.
    &#34;&#34;&#34;
    self.html = self.md.convert(self.pre)</code></pre>
</details>
</dd>
<dt id="wiki.core.Processor.process_meta"><code class="name flex">
<span>def <span class="ident">process_meta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get metadata.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;Can only be called after :meth:<code>html</code> was</p>
<p>called.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_meta(self):
    &#34;&#34;&#34;
        Get metadata.

        .. warning:: Can only be called after :meth:`html` was
            called.
    &#34;&#34;&#34;
    # the markdown meta plugin does not retain the order of the
    # entries, so we have to loop over the meta values a second
    # time to put them into a dictionary in the correct order
    self.meta = OrderedDict()
    for line in self.meta_raw.split(&#39;\n&#39;):
        key = line.split(&#39;:&#39;, 1)[0]
        # markdown metadata always returns a list of lines, we will
        # reverse that here
        self.meta[key.lower()] = \
            &#39;\n&#39;.join(self.md.Meta[key.lower()])</code></pre>
</details>
</dd>
<dt id="wiki.core.Processor.process_post"><code class="name flex">
<span>def <span class="ident">process_post</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Content postprocessor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_post(self):
    &#34;&#34;&#34;
        Content postprocessor.
    &#34;&#34;&#34;
    current = self.html
    for processor in self.postprocessors:
        current = processor(current)
    self.final = current</code></pre>
</details>
</dd>
<dt id="wiki.core.Processor.process_pre"><code class="name flex">
<span>def <span class="ident">process_pre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Content preprocessor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_pre(self):
    &#34;&#34;&#34;
        Content preprocessor.
    &#34;&#34;&#34;
    current = self.input
    for processor in self.preprocessors:
        current = processor(current)
    self.pre = current</code></pre>
</details>
</dd>
<dt id="wiki.core.Processor.split_raw"><code class="name flex">
<span>def <span class="ident">split_raw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Split text into raw meta and content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_raw(self):
    &#34;&#34;&#34;
        Split text into raw meta and content.
    &#34;&#34;&#34;
    self.meta_raw, self.markdown = self.pre.split(&#39;\n\n&#39;, 1)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wiki.core.Wiki"><code class="flex name class">
<span>class <span class="ident">Wiki</span></span>
<span>(</span><span>root)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wiki(object):
    def __init__(self, root):
        self.root = root

    def path(self, url):
        return os.path.join(self.root, url + &#39;.md&#39;)

    def exists(self, url):
        path = self.path(url)
        return os.path.exists(path)

    def get(self, url):
        path = self.path(url)
        #path = os.path.join(self.root, url + &#39;.md&#39;)
        if self.exists(url):
            return Page(path, url)
        return None

    def get_or_404(self, url):
        page = self.get(url)
        if page:
            return page
        abort(404)

    def get_bare(self, url):
        path = self.path(url)
        if self.exists(url):
            return False
        return Page(path, url, new=True)

    def move(self, url, newurl):
        source = os.path.join(self.root, url) + &#39;.md&#39;
        target = os.path.join(self.root, newurl) + &#39;.md&#39;
        # normalize root path (just in case somebody defined it absolute,
        # having some &#39;../&#39; inside) to correctly compare it to the target
        root = os.path.normpath(self.root)
        # get root path longest common prefix with normalized target path
        common = os.path.commonprefix((root, os.path.normpath(target)))
        # common prefix length must be at least as root length is
        # otherwise there are probably some &#39;..&#39; links in target path leading
        # us outside defined root directory
        if len(common) &lt; len(root):
            raise RuntimeError(
                &#39;Possible write attempt outside content directory: &#39;
                &#39;%s&#39; % newurl)
        # create folder if it does not exists yet
        folder = os.path.dirname(target)
        if not os.path.exists(folder):
            os.makedirs(folder)
        os.rename(source, target)

    def delete(self, url):
        path = self.path(url)
        if not self.exists(url):
            return False
        os.remove(path)
        return True

    def index(self):
        &#34;&#34;&#34;
            Builds up a list of all the available pages.

            :returns: a list of all the wiki pages
            :rtype: list
        &#34;&#34;&#34;
        # make sure we always have the absolute path for fixing the
        # walk path
        pages = []
        root = os.path.abspath(self.root)
        for cur_dir, _, files in os.walk(root):
            # get the url of the current directory
            cur_dir_url = cur_dir[len(root)+1:]
            for cur_file in files:
                path = os.path.join(cur_dir, cur_file)
                if cur_file.endswith(&#39;.md&#39;):
                    url = clean_url(os.path.join(cur_dir_url, cur_file[:-3]))
                    page = Page(path, url)
                    pages.append(page)
        return sorted(pages, key=lambda x: x.title.lower())

    def index_by(self, key):
        &#34;&#34;&#34;
            Get an index based on the given key.

            Will use the metadata value of the given key to group
            the existing pages.

            :param str key: the attribute to group the index on.

            :returns: Will return a dictionary where each entry holds
                a list of pages that share the given attribute.
            :rtype: dict
        &#34;&#34;&#34;
        pages = {}
        for page in self.index():
            value = getattr(page, key)
            pre = pages.get(value, [])
            pages[value] = pre.append(page)
        return pages

    def get_by_title(self, title):
        pages = self.index(attr=&#39;title&#39;)
        return pages.get(title)

    def get_tags(self):
        pages = self.index()
        tags = {}
        for page in pages:
            pagetags = page.tags.split(&#39;,&#39;)
            for tag in pagetags:
                tag = tag.strip()
                if tag == &#39;&#39;:
                    continue
                elif tags.get(tag):
                    tags[tag].append(page)
                else:
                    tags[tag] = [page]
        return tags

    def index_by_tag(self, tag):
        pages = self.index()
        tagged = []
        for page in pages:
            if tag in page.tags:
                tagged.append(page)
        return sorted(tagged, key=lambda x: x.title.lower())

    def search(self, term, ignore_case=True, attrs=[&#39;title&#39;, &#39;tags&#39;, &#39;body&#39;]):
        pages = self.index()
        regex = re.compile(term, re.IGNORECASE if ignore_case else 0)
        matched = []
        for page in pages:
            for attr in attrs:
                if regex.search(getattr(page, attr)):
                    matched.append(page)
                    break
        return matched</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wiki.core.Wiki.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, url):
    path = self.path(url)
    if not self.exists(url):
        return False
    os.remove(path)
    return True</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, url):
    path = self.path(url)
    return os.path.exists(path)</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, url):
    path = self.path(url)
    #path = os.path.join(self.root, url + &#39;.md&#39;)
    if self.exists(url):
        return Page(path, url)
    return None</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.get_bare"><code class="name flex">
<span>def <span class="ident">get_bare</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bare(self, url):
    path = self.path(url)
    if self.exists(url):
        return False
    return Page(path, url, new=True)</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.get_by_title"><code class="name flex">
<span>def <span class="ident">get_by_title</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_title(self, title):
    pages = self.index(attr=&#39;title&#39;)
    return pages.get(title)</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.get_or_404"><code class="name flex">
<span>def <span class="ident">get_or_404</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_or_404(self, url):
    page = self.get(url)
    if page:
        return page
    abort(404)</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.get_tags"><code class="name flex">
<span>def <span class="ident">get_tags</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tags(self):
    pages = self.index()
    tags = {}
    for page in pages:
        pagetags = page.tags.split(&#39;,&#39;)
        for tag in pagetags:
            tag = tag.strip()
            if tag == &#39;&#39;:
                continue
            elif tags.get(tag):
                tags[tag].append(page)
            else:
                tags[tag] = [page]
    return tags</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds up a list of all the available pages.</p>
<p>:returns: a list of all the wiki pages
:rtype: list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self):
    &#34;&#34;&#34;
        Builds up a list of all the available pages.

        :returns: a list of all the wiki pages
        :rtype: list
    &#34;&#34;&#34;
    # make sure we always have the absolute path for fixing the
    # walk path
    pages = []
    root = os.path.abspath(self.root)
    for cur_dir, _, files in os.walk(root):
        # get the url of the current directory
        cur_dir_url = cur_dir[len(root)+1:]
        for cur_file in files:
            path = os.path.join(cur_dir, cur_file)
            if cur_file.endswith(&#39;.md&#39;):
                url = clean_url(os.path.join(cur_dir_url, cur_file[:-3]))
                page = Page(path, url)
                pages.append(page)
    return sorted(pages, key=lambda x: x.title.lower())</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.index_by"><code class="name flex">
<span>def <span class="ident">index_by</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an index based on the given key.</p>
<p>Will use the metadata value of the given key to group
the existing pages.</p>
<p>:param str key: the attribute to group the index on.</p>
<p>:returns: Will return a dictionary where each entry holds
a list of pages that share the given attribute.
:rtype: dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_by(self, key):
    &#34;&#34;&#34;
        Get an index based on the given key.

        Will use the metadata value of the given key to group
        the existing pages.

        :param str key: the attribute to group the index on.

        :returns: Will return a dictionary where each entry holds
            a list of pages that share the given attribute.
        :rtype: dict
    &#34;&#34;&#34;
    pages = {}
    for page in self.index():
        value = getattr(page, key)
        pre = pages.get(value, [])
        pages[value] = pre.append(page)
    return pages</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.index_by_tag"><code class="name flex">
<span>def <span class="ident">index_by_tag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_by_tag(self, tag):
    pages = self.index()
    tagged = []
    for page in pages:
        if tag in page.tags:
            tagged.append(page)
    return sorted(tagged, key=lambda x: x.title.lower())</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, url, newurl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, url, newurl):
    source = os.path.join(self.root, url) + &#39;.md&#39;
    target = os.path.join(self.root, newurl) + &#39;.md&#39;
    # normalize root path (just in case somebody defined it absolute,
    # having some &#39;../&#39; inside) to correctly compare it to the target
    root = os.path.normpath(self.root)
    # get root path longest common prefix with normalized target path
    common = os.path.commonprefix((root, os.path.normpath(target)))
    # common prefix length must be at least as root length is
    # otherwise there are probably some &#39;..&#39; links in target path leading
    # us outside defined root directory
    if len(common) &lt; len(root):
        raise RuntimeError(
            &#39;Possible write attempt outside content directory: &#39;
            &#39;%s&#39; % newurl)
    # create folder if it does not exists yet
    folder = os.path.dirname(target)
    if not os.path.exists(folder):
        os.makedirs(folder)
    os.rename(source, target)</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.path"><code class="name flex">
<span>def <span class="ident">path</span></span>(<span>self, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path(self, url):
    return os.path.join(self.root, url + &#39;.md&#39;)</code></pre>
</details>
</dd>
<dt id="wiki.core.Wiki.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, term, ignore_case=True, attrs=['title', 'tags', 'body'])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, term, ignore_case=True, attrs=[&#39;title&#39;, &#39;tags&#39;, &#39;body&#39;]):
    pages = self.index()
    regex = re.compile(term, re.IGNORECASE if ignore_case else 0)
    matched = []
    for page in pages:
        for attr in attrs:
            if regex.search(getattr(page, attr)):
                matched.append(page)
                break
    return matched</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wiki" href="index.html">wiki</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wiki.core.clean_url" href="#wiki.core.clean_url">clean_url</a></code></li>
<li><code><a title="wiki.core.wikilink" href="#wiki.core.wikilink">wikilink</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wiki.core.Page" href="#wiki.core.Page">Page</a></code></h4>
<ul class="two-column">
<li><code><a title="wiki.core.Page.html" href="#wiki.core.Page.html">html</a></code></li>
<li><code><a title="wiki.core.Page.load" href="#wiki.core.Page.load">load</a></code></li>
<li><code><a title="wiki.core.Page.meta" href="#wiki.core.Page.meta">meta</a></code></li>
<li><code><a title="wiki.core.Page.render" href="#wiki.core.Page.render">render</a></code></li>
<li><code><a title="wiki.core.Page.save" href="#wiki.core.Page.save">save</a></code></li>
<li><code><a title="wiki.core.Page.tags" href="#wiki.core.Page.tags">tags</a></code></li>
<li><code><a title="wiki.core.Page.title" href="#wiki.core.Page.title">title</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wiki.core.Processor" href="#wiki.core.Processor">Processor</a></code></h4>
<ul class="two-column">
<li><code><a title="wiki.core.Processor.postprocessors" href="#wiki.core.Processor.postprocessors">postprocessors</a></code></li>
<li><code><a title="wiki.core.Processor.preprocessors" href="#wiki.core.Processor.preprocessors">preprocessors</a></code></li>
<li><code><a title="wiki.core.Processor.process" href="#wiki.core.Processor.process">process</a></code></li>
<li><code><a title="wiki.core.Processor.process_markdown" href="#wiki.core.Processor.process_markdown">process_markdown</a></code></li>
<li><code><a title="wiki.core.Processor.process_meta" href="#wiki.core.Processor.process_meta">process_meta</a></code></li>
<li><code><a title="wiki.core.Processor.process_post" href="#wiki.core.Processor.process_post">process_post</a></code></li>
<li><code><a title="wiki.core.Processor.process_pre" href="#wiki.core.Processor.process_pre">process_pre</a></code></li>
<li><code><a title="wiki.core.Processor.split_raw" href="#wiki.core.Processor.split_raw">split_raw</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wiki.core.Wiki" href="#wiki.core.Wiki">Wiki</a></code></h4>
<ul class="two-column">
<li><code><a title="wiki.core.Wiki.delete" href="#wiki.core.Wiki.delete">delete</a></code></li>
<li><code><a title="wiki.core.Wiki.exists" href="#wiki.core.Wiki.exists">exists</a></code></li>
<li><code><a title="wiki.core.Wiki.get" href="#wiki.core.Wiki.get">get</a></code></li>
<li><code><a title="wiki.core.Wiki.get_bare" href="#wiki.core.Wiki.get_bare">get_bare</a></code></li>
<li><code><a title="wiki.core.Wiki.get_by_title" href="#wiki.core.Wiki.get_by_title">get_by_title</a></code></li>
<li><code><a title="wiki.core.Wiki.get_or_404" href="#wiki.core.Wiki.get_or_404">get_or_404</a></code></li>
<li><code><a title="wiki.core.Wiki.get_tags" href="#wiki.core.Wiki.get_tags">get_tags</a></code></li>
<li><code><a title="wiki.core.Wiki.index" href="#wiki.core.Wiki.index">index</a></code></li>
<li><code><a title="wiki.core.Wiki.index_by" href="#wiki.core.Wiki.index_by">index_by</a></code></li>
<li><code><a title="wiki.core.Wiki.index_by_tag" href="#wiki.core.Wiki.index_by_tag">index_by_tag</a></code></li>
<li><code><a title="wiki.core.Wiki.move" href="#wiki.core.Wiki.move">move</a></code></li>
<li><code><a title="wiki.core.Wiki.path" href="#wiki.core.Wiki.path">path</a></code></li>
<li><code><a title="wiki.core.Wiki.search" href="#wiki.core.Wiki.search">search</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>